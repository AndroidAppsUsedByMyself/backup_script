#!/system/bin/sh
rm -rf /data/media/0/Android/backup_script/自動備份信息.txt
log() {
	echo "$(date '+%T') backup: $1" >>"/data/media/0/Android/backup_script/自動備份信息.txt"
}
MODDIR="${0%/*}"
tools_path="$MODDIR/recovery/tools"
[[ ! -d $tools_path ]] && log "$tools_path目錄遺失" && exit 1
. "$tools_path/bin.sh"
. "/data/media/0/Android/backup_script/backup_settings.conf"

i=1
path=/data/media/0/Android
path2=/data/user/0
Backup="/data/media/0/Android/backup_script/Backup_$Compression_method"
system="
com.google.android.apps.messaging
com.digibites.accubattery
com.google.android.inputmethod.latin
com.android.chrome"
#充電狀態
status="$(dumpsys deviceidle get charging)"
[[ $status != true ]] && log "非充電狀態 跳過備份"
get_launcher() {
	if [[ $(getprop ro.build.version.sdk) -gt 27 ]]; then
		# 获取默认桌面
		launcher_app="$(pm resolve-activity --brief -c android.intent.category.HOME -a android.intent.action.MAIN | grep '/' | cut -f1 -d '/')"
		for launcher_app in $launcher_app; do
			if [[ $launcher_app != "" && $launcher_app != "android" ]]; then
				if [[ $(pgrep -f "$launcher_app" | grep -v 'grep' | wc -l) -ge 1 ]]; then
					echo "$launcher_app"
				fi
			fi
		done
	fi
}
txt="${Backup%/*}/Apkname.txt"
if [[ ! -e $txt ]]; then
	log "第一次備份 生成$txt 五分鐘後開始備份請把握時間編輯備份列表"
	sleep_backup=1
	toast "第一次備份 生成$txt 五分鐘後開始備份請把握時間編輯備份列表"
	echo "第一次備份 生成$txt 五分鐘後開始備份請把握時間編輯備份列表"
fi
appinfo -d " " -o ands,pn -pn $system $(get_launcher) -3 2>/dev/null | sort | while read name; do
	txt="${Backup%/*}/Apkname.txt"
	[[ ! -e $txt ]] && echo "#不需要備份的應用請在開頭注釋# 比如#xxxxxxxx 酷安" >"$txt"
	if [[ $(cat "$txt" | sed -e '/^$/d' | grep -w "$name") = "" ]]; then
		echo "$name" >>"$txt"
	fi
done
[[ ! -e $txt ]] && log "Apkname.txt不存在" && exit 2
r="$(cat "$txt" | grep -v "#" | sed -e '/^$/d' | sed -n '$=')"
[[ $r = "" ]] && log "Apkname.txt是空" && exit 1
data=/data
hx="本地"
if [[ $(pm path y.u.k) = "" ]]; then
	log "未安裝toast 開始安裝"
	if [[ $(getenforce) != Permissive ]]; then
		setenforce 0 2>/dev/null
		if [[ $? = 0 ]]; then
			log "selinux關閉成功" && pm install -r "$tools_path/apk"/*.apk >/dev/null 2>&1 && log "安裝toast成功" || log "安裝toast失敗"
		else
			log "selinux關閉失敗 使用cp安裝toast" &&  cp -r "$tools_path/apk"/*.apk /data/local/tmp && pm install -r /data/local/tmp/*.apk >/dev/null 2>&1 && (rm -rf /data/local/tmp/* && log "安裝toast成功") || log "安裝toast失敗"
		fi
	else
		pm install -r "$tools_path/apk"/*.apk >/dev/null 2>&1 && log "安裝toast成功" || log "安裝toast失敗"
	fi
fi
[[ $sleep_backup != "" ]] && sleep 300
log "-壓縮方式:$Compression_method"
[[ ! -d $Backup ]] && mkdir "$Backup"
[[ ! -e $Backup/name.txt ]] && echo "#不需要恢復還原的應用請在開頭注釋# 比如#xxxxxxxx 酷安" >"$Backup/name.txt"
[[ ! -d $Backup/tools ]] && cp -r "$tools_path" "$Backup" && rm -rf "$Backup/tools"/restore* && rm -rf "$Backup/tools/apk" && rm -rf "$Backup/tools/toast" && rm -rf "$Backup/tools/Magisk_backup" && rm -rf "$Backup/tools/bash"
[[ ! -e $Backup/還原備份.sh ]] && cp -r "$tools_path/restore" "$Backup/還原備份.sh"
filesize="$(du -ks "$Backup" | awk '{print $1}')"
#調用二進制
Quantity=0
compression() {
	if [[ $1 != user ]]; then
		case $3 in
		tar|Tar|TAR) tar -cPpf "$Backup_folder/$1.tar" "$2" 2>/dev/null ;;
		zstd|Zstd|ZSTD) tar -cPpf - "$2" 2>/dev/null | zstd -r -T0 -6 -q >"$Backup_folder/$1.tar.zst" ;;
		lz4|Lz4|LZ4) tar -cPpf - "$2" 2>/dev/null | lz4 -1 >"$Backup_folder/$1.tar.lz4" ;;
		*) log "$3為不支持的壓縮算法" && rm -rf "$Backup" && exit 2
		esac
	else
		case $3 in
		tar|Tar|TAR) tar --exclude="$2/cache" --exclude="$2/lib" -cPpf "$Backup_folder/$1.tar" "$2" 2>/dev/null ;;
		zstd|Zstd|ZSTD) tar --exclude="$2/cache" --exclude="$2/lib" -cPpf - "$2" 2>/dev/null | zstd -r -T0 -6 -q >"$Backup_folder/$1.tar.zst" ;;
		lz4|Lz4|LZ4) tar --exclude="$2/cache" --exclude="$2/lib" -cPpf - "$2" 2>/dev/null | lz4 -1 >"$Backup_folder/$1.tar.lz4" ;;
		*) log "$3為不支持的壓縮算法" && rm -rf "$Backup" && exit 2
		esac
	fi
}
#顯示執行結果
echo_log() {
	if [[ $? = 0 ]]; then
		log "$1成功" && result=0
	else
		log "$1備份失敗，過世了" && result=1
	fi
}
#檢測apk狀態進行備份
Backup_apk() {
	#創建APP備份文件夾
	[[ ! -d $Backup_folder ]] && mkdir "$Backup_folder"
	#備份apk
	apk_path="$(pm path "$name" | cut -f2 -d ':')"
	log "$1"
	[[ $(cat "$Backup/name.txt" | sed -e '/^$/d' | grep -w "$name" | head -1) = "" ]] && echo "$name2 $name" >>"$Backup/name.txt"
	if [[ $apk_version = $(pm dump "$name" | grep -m 1 versionName | sed -n 's/.*=//p') ]]; then
		unset xb
		log "Apk版本無更新 跳過備份"
	else
		rm -rf "$Backup_folder"/*.apk
		if [[ $apk_number = 1 ]]; then
			cp -r "$apk_path" "$Backup_folder/"
		else
			pm path "$name" | cut -f2 -d ':' | while read aof; do
				cp -r "$aof" "$Backup_folder/"
			done
		fi
		echo_log "備份$apk_number個Apk"
		if [[ $result = 0 ]]; then
			echo "apk_version=$(pm dump "$name" | grep -m 1 versionName | sed -n 's/.*=//p')" >>"$app_details"
			[[ $PackageName = "" ]] && echo "PackageName=$name">>"$app_details"
		fi
	fi
	if [[ $name = com.android.chrome ]]; then
		#刪除所有舊apk ,保留一個最新apk進行備份
		ReservedNum=1
		FileNum="$(ls /data/app/*/com.google.android.trichromelibrary_*/base.apk 2>/dev/null | wc -l)"
		while [[ $FileNum -gt $ReservedNum ]]; do
			OldFile="$(ls -rt /data/app/*/com.google.android.trichromelibrary_*/base.apk 2>/dev/null | head -1)"
			log "刪除文件:${OldFile%/*/*}"
			rm -rf "${OldFile%/*/*}"
			let "FileNum--"
		done
		if [[ -e $(ls /data/app/*/com.google.android.trichromelibrary_*/base.apk 2>/dev/null) && $(ls /data/app/*/com.google.android.trichromelibrary_*/base.apk 2>/dev/null | wc -l) = 1 ]]; then
			cp -r "$(ls /data/app/*/com.google.android.trichromelibrary_*/base.apk 2>/dev/null)" "$Backup_folder/nmsl.apk"
			echo_log "備份com.google.android.trichromelibrary"
		fi
	fi
}
#檢測數據位置進行備份
Backup_data() {
	if [[ $1 = user ]]; then
		data_path="$path2/$name"
	else
		data_path="$path/$1/$name"
	fi
	if [[ -d $data_path ]]; then
		case $1 in
			user) Size="$userSize" ;;
			data) Size="$dataSize" ;;
			obb) Size="$obbSize" ;;
		esac
		if [[ $Size = "" ]]; then
			nsxg=1
		else
			if [[ $Size != $(du -ks "$data_path" | awk '{print $1}') ]]; then
				nsxg=1
			else
				log "$1數據無發生變化 跳過備份"
				unset nsxg
			fi
		fi
		if [[ $nsxg != "" ]]; then
			compression "$1" "$data_path" "$Compression_method"
			echo_log "備份$1數據"
			[[ $result = 0 ]] && echo "$1Size=$(du -ks "$data_path" | awk '{print $1}')" >>"$app_details"
		fi
	else
		log "$1數據不存在跳過備份"
	fi
}
unset endtime
endtime() {
	#計算總體切換時長耗費
	case $1 in
	1) starttime="$starttime1" ;;
	2) starttime="$starttime2" ;;
	esac
	endtime="$(date -u "+%s")"
	duration="$(echo "$((endtime - starttime))" | awk '{t=split("60 秒 60 分 24 時 999 天",a);for(n=1;n<t;n+=2){if($1==0)break;s=$1%a[n]a[n+1]s;$1=int($1/a[n])}print s}')"
	[[ $duration != "" ]] && log "$2用時:$duration" || log "$2用時:0秒"
}
#開始循環$txt內的資料進行備份
#記錄開始時間
starttime1="$(date -u "+%s")"
toast "自動備份$r個應用中 CPU佔用極高可能帶來卡頓 請注意備份結束即可恢復"
{
while [[ $i -le $r ]]; do
	log "備份第$i個應用 總共$r個 剩下$((r-i))個應用"
	name="$(cat "$txt" | grep -v "#" | sed -e '/^$/d' | sed -n "${i}p" | awk '{print $2}')"
	name2="$(cat "$txt" | grep -v "#" | sed -e '/^$/d' | sed -n "${i}p" | awk '{print $1}')"
	if [[ $name2 = *! || $name2 = *！ ]]; then
		name2=$(echo "$name2" | sed 's/!//g' | sed 's/！//g')
		log "跳過備份$name2 所有數據" 
		No_backupdata=1
	else
		[[ $No_backupdata != "" ]] && unset No_backupdata
	fi
	Backup_folder="$Backup/$name2($name)"
	app_details="$Backup_folder/app_details"
	[[ -e $app_details ]] && . "$app_details"
	[[ $name = "" ]] && log "警告! name.txt軟件包名獲取失敗，可能修改有問題" && exit 1
	if [[ $(pm path "$name") != "" ]]; then
		starttime2="$(date -u "+%s")"
		log "備份$name2 ($name)"
		[[ $name = com.tencent.mobileqq ]] && log "QQ可能恢復備份失敗或是丟失聊天記錄，請自行用你信賴的軟件備份"
		[[ $name = com.tencent.mm ]] && log "WX可能恢復備份失敗或是丟失聊天記錄，請自行用你信賴的軟件備份"
		apk_number="$(pm path "$name" | cut -f2 -d ':' | wc -l)"
		if [[ $apk_number = 1 ]]; then
			[[ $name != $Open_apps ]] && am force-stop "$name"
			Backup_apk "非Split Apk"
		else
			[[ $name != $Open_apps ]] && am force-stop "$name"
			Backup_apk "Split Apk支持備份"
		fi
		[[ ! -e $Backup_folder/恢復$name2.sh ]] && cp -r "$tools_path/restore2" "$Backup_folder/恢復$name2.sh"
		[[ $name = bin.mt.plus && -e $Backup_folder/base.apk ]] && cp -r "$Backup_folder/base.apk" "$Backup_folder.apk"
		[[ $No_backupdata = "" ]] && {
		if [[ $Backup_obb_data = true ]]; then
			#備份data數據
			Backup_data "data"
			#備份obb數據
			Backup_data "obb"
		fi
		#備份user數據
		Backup_data "user"
		}
		endtime 2 "$name2備份"
		log "完成$((i*100/r))% $hx$(df -h "$data" | awk 'END{print "剩餘:"$3"使用率:"$4}')"
	else
		log "$name2[$name]不在安裝列表 跳過備份"
	fi
	log
	lxj="$(df -h "$data" | awk 'END{print $4}' | sed 's/%//g')"
	[[ $lxj -ge 95 ]] && log "$data空間不足,達到$lxj%" && exit 2
	let i++
done
#計算出備份大小跟差異性
filesizee="$(du -ks "$Backup" | awk '{print $1}')"
dsize="$(($((filesizee - filesize)) / 1024))"
log "備份資料夾路徑:$Backup"
log "備份資料夾總體大小$(du -ksh "$Backup" | awk '{print $1}')"
if [[ $dsize -gt 0 ]]; then
	if [[ $((dsize / 1024)) -gt 0 ]]; then
		log "本次備份: $((dsize / 1024))gb"
	else
		log "本次備份: ${dsize}mb"
	fi
else
	log "本次備份: $(($((filesizee - filesize)) * 1000 / 1024))kb"
fi
log "批量備份完成"
[[ $(pm path y.u.k) != "" ]] && toast "批量備份完成"
endtime 1 "批量備份開始到結束"
exit 0
}&