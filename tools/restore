#!/system/bin/sh
test "$(id -u)" -ne 0 && echo "你是憨批？不給Root用你媽 爬" && exit 1
MODDIR="${0%/*}"
[[ $(echo "$MODDIR" | grep -v 'mt') = "" ]] && echo "草泥馬不解壓縮？用毛線 憨批" && exit 1
[[ ! -d $MODDIR/tools ]] && echo "$MODDIR/tools目錄遺失" && exit 1
tools_path="$MODDIR/tools"
. "$tools_path/bin.sh"
path=/data/media/0/Android
path2=/data/user/0
[[ ! -d $path2 ]] && echoRgb "設備不存在user目錄" "0" "0" && exit 1
#記錄開始時間
starttime1="$(date -u "+%s")"
i=1
txt="$MODDIR/name.txt"
[[ ! -e $txt ]] && echo "$txt缺少" && exit 0
r="$(cat "$txt" | grep -v "#" | sed -e '/^$/d' | sed -n '$=')"
[[ $r = "" ]] && echoRgb "name.txt包名為空或是被注釋了" "0" "0" && exit 1
#顯示執行結果
echo_log() {
	if [[ $? = 0 ]]; then
		echoRgb "$1成功" "0" "1" && result=0
	else
		echoRgb "$1恢複失敗，過世了" "0" "0" && result=1 && let ERROR++
	fi
}
Release_data() {
	FILE_NAME="$(basename "$1")"
	FILE_NAME2="${FILE_NAME%%.*}"
	echoRgb "恢復$FILE_NAME2數據" "0" "2"
	case $FILE_NAME in
	user.tar*|data.tar*|obb.tar*|Pictures.tar*|Music.tar*|DCIM.tar*)
		case $FILE_NAME in
		*.lz4)
			pv "$1" | tar --recursive-unlink -I lz4 -xmPpf - ;;
		*.zst)
			pv "$1" | tar --recursive-unlink -I zstd -xmPpf - ;;
		*.tar)
			pv "$1" | tar --recursive-unlink -xmPpf - ;;
		esac ;;
	esac
	echo_log "$FILE_NAME解壓縮($FILE_NAME2)"
}
bn=37
#開始循環$txt內的資料進行恢複
#記錄error次數起點
ERROR=1
{
while [[ $i -le $r ]]; do
	#let bn++
	#[[ $bn -ge 37 ]] && bn=31
	echoRgb "恢複第$i個應用 總共$r個 剩下$((r-i))個應用"
	name="$(cat "$txt" | grep -v "#" | sed -e '/^$/d' | sed -n "${i}p" | awk '{print $2}')"
	name2="$(cat "$txt" | grep -v "#" | sed -e '/^$/d' | sed -n "${i}p" | awk '{print $1}')"
	Backup_folder="$MODDIR/$name2($name)"
	Backup_folder2="$MODDIR/媒體"
	[[ $name = "" ]] && echoRgb "警告! name.txt軟件包名獲取失敗，可能修改有問題" "0" "0" && exit 1
	if [[ -d $Backup_folder ]]; then
		echoRgb "恢複$name2 ($name)"
		starttime2="$(date -u "+%s")"
		if [[ $(pm path "$name") = "" ]]; then
			TMPDIR="/data/local/tmp"
			rm -rf "$TMPDIR"/*
			cp -r "$Backup_folder"/*.apk "$TMPDIR"
			case $(find "$TMPDIR" -maxdepth 1 -name "*.apk" -type f 2>/dev/null | wc -l) in
			1)
				echoRgb "恢復普通apk"
				pm install -r /data/local/tmp/*.apk >/dev/null 2>&1
				echo_log "Apk安裝"
				;;
			0)
				echoRgb "你的Apk離家出走了，可能備份後移動過程遺失了 解決辦法手動安裝Apk後再執行恢復腳本" "0" "0"
				;;
			*)
				echoRgb "恢復split apk"
				b="$(pm install-create | grep -E -o '[0-9]+')"
				if [[ -e $TMPDIR/nmsl.apk ]]; then
					pm install -r "/data/local/tmp/nmsl.apk" >/dev/null 2>&1
					echo_log "nmsl.apk安裝"
				fi
				find "$TMPDIR" -maxdepth 1 -name "*.apk" -type f | while read i; do
					ad="$(basename "$i" | grep -v 'nmsl.apk')"
					if [[ $ad != "" ]]; then
						pm install-write "$b" "$ad" "$TMPDIR/$ad" >/dev/null 2>&1
						echo_log "$(basename "$i")安裝"
					else
						echoRgb "涼了 basename階段出錯" "0" "0" && exit
					fi
				done
				pm install-commit "$b"
				echo_log "split Apk安裝"
				;;
			esac
			rm -rf "$TMPDIR"/*
		else
			echoRgb "存在當前系統中略過安裝Apk"
		fi
		zb="$(pm list packages | grep -w "$name" | sed 's/package://g')"
		if [[ $zb != "" ]]; then
			if [[ $zb = $name ]]; then
				#停止軟件
				[[ $name != $Open_apps ]] && am force-stop "$name"
				if [[ -e /config/sdcardfs/$name/appid ]]; then
					G="$(cat "/config/sdcardfs/$name/appid")"
				else
					G="$(dumpsys package "$name" | awk '/userId=/{print $1}' | sed 's/userId=//g' | head -1)"
				fi
				X="$path2/$name"
				find "$Backup_folder" -name "*.tar*" -type f | while read i; do
					Release_data "$i"
				done
				if [[ -d $X && $G != "" ]]; then
					echoRgb "路徑$X
 權限:$G:$G"
					chown -R "$G:$G" "$X"
					echo_log "數據恢複"
				else
					[[ ! -d $X ]] && echoRgb "路徑$X不存在" "0" "0" ; [[ $G = "" ]] && echoRgb "user權限uid獲取失敗" "0" "0"
					echoRgb "由於上列提示錯誤數據恢複失敗" "0" "0"
				fi
			else
				echoRgb "E $zb != $name" "0" "0"
			fi
		else
			echoRgb "Apk沒有安裝無法恢復數據" "0" "0"
		fi
		endtime 2 "恢複" && echoRgb "完成$((i*100/r))%" && echoRgb
	else
		echoRgb "$Backup_folder資料夾遺失，無法恢複" "0" "0"
	fi
	if [[ $i = $r ]]; then
		if [[ -d $Backup_folder2 ]]; then
			echoRgb "是否恢復多媒體數據
 音量上恢復，音量下不恢復"
			get_version "恢復媒體數據" "跳過恢復媒體數據"
			if [[ $branch = true ]]; then
				find "$Backup_folder2" -name "*.tar*" -type f | while read i; do
					Release_data "$i"
				done
			fi
		fi
	fi
	if [[ $ERROR -ge 5 ]]; then
		echoRgb "錯誤次數達到上限 環境已重設" "0" "0" && rm -rf "$filepath"
		echoRgb "請重新執行腳本" "0" "0" && exit
	fi
	let i++
done
echoRgb "批量恢複完成" && endtime 1 "批量恢複開始到結束" && echoRgb "軟件閃退請重新開機" "0" "2"
} &