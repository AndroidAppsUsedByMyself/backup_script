#!/system/bin/sh
test "$(id -u)" -ne 0 && echo "你是憨批？不給Root用你媽 爬" && exit 1
MODDIR="${0%/*}"
[[ ! -d ${MODDIR%/*}/tools ]] && echo "${MODDIR%/*}/tools目錄遺失" && exit 1
tools_path="${MODDIR%/*}/tools"
. "$tools_path/bin.sh"
path=/data/media/0/Android
path2=/data/user/0
[[ ! -d $path2 ]] && echoRgb "設備不存在user目錄" "0" "0" && exit 1
#記錄開始時間
starttime1="$(date -u "+%s")"
Set_back() {
	return 1
}
#顯示執行結果
echo_log() {
	if [[ $? = 0 ]]; then
		echoRgb "$1成功" "0" "1" && result=0
	else
		echoRgb "$1恢複失敗，過世了" "0" "0" && result=1
	fi
}
Release_data() {
	tar_path="$1"
	FILE_NAME="${tar_path##*/}"
	FILE_NAME2="${FILE_NAME%%.*}"
	echoRgb "恢復$FILE_NAME2數據" "0" "2" && usertar="1"
	case ${FILE_NAME##*.} in
	lz4) pv "$1" | tar --recursive-unlink -I lz4 -xmPpf - ;;
	zst) pv "$1" | tar --recursive-unlink -I zstd -xmPpf - ;;
	tar) pv "$1" | tar --recursive-unlink -xmPpf - ;;
	*) (echoRgb "$FILE_NAME 壓縮包不支持解壓縮" "0" "0" ; [[ $FILE_NAME2 = user ]] && unset usertar ; Set_back)
	esac
	echo_log "$FILE_NAME 解壓縮($FILE_NAME2)"
}
bn=37
{
Backup_folder="$MODDIR"
if [[ ! -e $Backup_folder/app_details ]]; then
	echoRgb "$Backup_folder/app_details遺失，無法獲取包名" "0" "0" && exit 1
else
	. "$Backup_folder/app_details"
fi
name="$PackageName"
name2="$(basename "$Backup_folder"/恢復*.sh | sed 's/恢復//g ; s/.sh//g')"
echoRgb "恢複$name2 ($name)"
starttime2="$(date -u "+%s")"
if [[ $(pm path "$name") = "" ]]; then
	TMPDIR="/data/local/tmp"
	rm -rf "$TMPDIR"/*
	cp -r "$Backup_folder"/*.apk "$TMPDIR"
	case $(find "$TMPDIR" -maxdepth 1 -name "*.apk" -type f 2>/dev/null | wc -l) in
	1)
		echoRgb "恢復普通apk"
		pm install -r /data/local/tmp/*.apk >/dev/null 2>&1
		echo_log "Apk安裝"
		;;
	0)
		echoRgb "你的Apk離家出走了，可能備份後移動過程遺失了 解決辦法手動安裝Apk後再執行恢復腳本" "0" "0"
		;;
	*)
		echoRgb "恢復split apk"
		b="$(pm install-create | grep -E -o '[0-9]+')"
		if [[ -e $TMPDIR/nmsl.apk ]]; then
			pm install -r "/data/local/tmp/nmsl.apk" >/dev/null 2>&1
			echo_log "nmsl.apk安裝"
		fi
		find "$TMPDIR" -maxdepth 1 -name "*.apk" -type f | while read i; do
			ad="$(echo "${i##*/}" | grep -v 'nmsl.apk')"
			if [[ $ad != "" ]]; then
				pm install-write "$b" "$ad" "$TMPDIR/$ad" >/dev/null 2>&1
				echo_log "${i##*/}安裝"
			else
				echoRgb "split apk安裝 ad變量為空" "0" "0" && exit 2
			fi
		done
		pm install-commit "$b"
		echo_log "split Apk安裝"
		;;
	esac
	rm -rf "$TMPDIR"/*
else
	echoRgb "存在當前系統中略過安裝Apk"
fi
zb="$(pm list packages | grep -w "$name" | cut -f2 -d ':')"
if [[ $zb != "" ]]; then
	if [[ $zb = $name ]]; then
		#停止軟件
		[[ $name != $Open_apps ]] && am force-stop "$name"
		if [[ -e /config/sdcardfs/$name/appid ]]; then
			G="$(cat "/config/sdcardfs/$name/appid")"
		else
			G="$(dumpsys package "$name" | awk '/userId=/{print $1}' | cut -f2 -d '=' | head -1)"
		fi
		X="$path2/$name"
		find "$Backup_folder" -name "*.tar*" -type f | while read i; do
			Release_data "$i"
		done
		if [[ -d $X ]]; then
			if [[ $G != "" ]]; then
				if [[ $uaertar != "" ]]; then
					echoRgb "路徑$X
 權限:$G:$G"
					chown -R "$G:$G" "$X"
					echo_log "數據恢複"
				fi
			else
				echoRgb "user權限uid獲取失敗" "0" "0"
			fi
		else
			echoRgb "路徑$X不存在" "0" "0"
		fi
	else
		echoRgb "$zb != $name" "0" "0"
	fi
else
	echoRgb "Apk沒有安裝無法恢復數據" "0" "0"
fi
endtime 1 "恢複開始到結束" && echoRgb "軟件閃退請重新開機" "0" "2"
} &